const objectobserver = require("objectobserver");

/**
 * @see lsObStruct in lsOb.h
 */
exports.Object = function (proxy, owner, worldInstance, id, isAppObject, name, notifyGroup) {
	this.owner = owner;
	this.proxy = proxy;
	this.worldInstance = worldInstance;	// worldInst
	
	this.id = id || worldInstance.world.server.generateId();	// oid
	
	this.groups = [];
	this.observers = [];	// obObservers
	this.sharedObservers = [];	// sharedObservers
	this.sayingQueue = [];	// sayQueue
	this.lastSayingTime = undefined;	// lastSaid
	
	this.nickName = undefined;	// nickname
	this.approvedAvatarId = -1;	// approvedAvOffset
	this.remoteId = -1;	// mapId
	this.name = name;
	this.isGlobal = true;	// global
	this.properties = {};
	
	if (isAppObject) worldInstance.appObjects.push(id);
	
	this.proxy.objects.push(this);
	if (notifyGroup) worldInstance.group.addObject(this);
};

exports.Object.prototype = {
	_avatarUrl: undefined,
	get avatarUrl() {
		return this._avatarUrl;
	},
	set avatarUrl(url) {
		this._avatarUrl = url;
		this.markAsDirty(objectobserver.dirtyAttrsAvatar);
	},
	
	_position: [[0, 0, 0], [0, 0, 0]],
	get position() {
		return this._position;
	},
	set position(pos) {
		this._position = pos;
		this.markAsDirty(objectobserver.dirtyAttrsPosition);
	},
};

exports.Object.prototype.isAppObject = function () {
	return this.worldInstance.appObjects.indexOf(this.id) >= 0;
};

/**
 * @see lsObObserverBegin in lsObObserver.h
 */
exports.Object.prototype.addObserver = function (socket) {
	var observer;
	for (var i = 0; i < this.observers.length; i++) {
		if (this.observers[i].socket == socket) {
			observer = this.observers[i];
			break;
		}
	}
	if (observer) observer.numInstances++;
	else new objectobserver.ObjectObserver(this, socket);
};

/**
 * @see lsObObserverEnd in lsObObserver.c
 */
exports.Object.prototype.removeObserver = function (socket) {
	var idx = this.observers.findIndex(function (observer, idx, observers) {
		return observer.socket === socket;
	});
	if (idx < 0) return;	// TODO: Also log.
	var observer = this.observers[idx];
	if (--observer.numInstances > 0) return;
	
	// lsObObserverKill() in lsObObserver.c
	socket.removeObserver(observer);
	// lsObDelObObserver() in lsOb.c
	this.observers.splice(idx, 1);
};

/**
 * @see lsObDirty() in lsOb.c
 */
exports.Object.prototype.markAsDirty = function (attrs) {
	this.observers.forEach(function (obs, idx, arr) {
		if (obs.dirty) obs.dirty |= attrs;
		else if ((obs.dirty = attrs)) obs.socket.dirtyObservers.push(obs);
	});
};

/**
 * @see lsEndBroadcast() in lsWorld.c
 */
exports.Object.prototype.endBroadcast = function () {
	// TODO: Lots more to fill in here.
	this.proxy.send(new types.Broadcast1({
		clientIdent: this.proxy.clientIdent,
		worldName: this.worldInstance.world.worldName,
		info: "END",
		oid: this.id,
	}));
};

/**
 * @see lsObKill() in lsOb.c
 */
exports.Object.prototype.detach = function () {
	var proxy = this.proxy;
	if (!proxy) return;
	if (proxy.broadcastMode) this.endBroadcast();
	if (proxy.dependencyLevel === proxy.DEPENDENCY_LEVEL_SLAVE && this.isGlobal) {
		// TODO: Call lsRemoteMaster_ObKill() on remote master.
	}
	for (var i = this.groups.length - 1; i >= 0; i--) {
		this.groups[i].removeObject(this);
	}
	for (var i = this.observers.length - 1; i >= 0; i--) {
		proxy.removeObserver(this.observers[i]);
	}
	this.properties = {};
	this.sharedObservers = [];
	
	// lsRemoteClientDelOb()
	var idxInProxy = proxy.objects.indexOf(this);
	if (idxInProxy >= 0) proxy.objects.splice(idxInProxy, 1);	// TODO: Else log.
	
	this.worldInstance.removeAppObject(this);
	
	this.groups = [];
	this.observers = [];
	this.sayingQueue = [];
	delete this.proxy;
};
